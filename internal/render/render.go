package render

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"helm.sh/helm/v4/pkg/engine"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/yaml"

	ovnoperatorv1 "github.com/harvester/kubeovn-operator/api/v1"
	"github.com/harvester/kubeovn-operator/internal/templates"
)

type values struct {
	Values ovnoperatorv1.ConfigurationSpec `json:"Values"`
}

func GenerateObjects(templates []string, config *ovnoperatorv1.Configuration, object client.Object, restConfig *rest.Config, version string) ([]client.Object, error) {
	var returnedObjects []client.Object

	// patch version supplied by the controller
	config.Spec.Global.Images.KubeOVNImage.Tag = version

	valsObj, err := generateMap(config)
	if err != nil {
		return nil, fmt.Errorf("failed to generate values: %w", err)
	}

	err = unstructured.SetNestedField(valsObj, config.GetNamespace(), "Values", "namespace")
	if err != nil {
		return nil, fmt.Errorf("failed to set namespace field in values map: %v", err)
	}

	// additional fields needed which are generated by the helper template in the helm chart
	kubeovn := generateIncludeValues(config)
	valsObj["kubeovn"] = kubeovn
	masterNodes := strings.Join(config.Status.MatchingNodeAddresses, ",")
	err = unstructured.SetNestedField(valsObj, masterNodes, "Values", "MASTER_NODES")
	if err != nil {
		return nil, fmt.Errorf("failed to set field MASTER_NODES in values map: %v", err)
	}

	for _, sourceTemplate := range templates {
		returnedObject, err := generateObject(sourceTemplate, valsObj, object, restConfig)
		if err != nil {
			return nil, fmt.Errorf("error returned from generateTemplate: %v", err)
		}
		if returnedObject != nil {
			returnedObjects = append(returnedObjects, returnedObject)
		}
	}
	return returnedObjects, nil
}

func generateObject(input string, valuesObj map[string]interface{}, object client.Object, restConfig *rest.Config) (client.Object, error) {
	newObj := InitialiseNewObject(object)
	if newObj == nil {
		return nil, fmt.Errorf("could not initialise new object for type: %T", object)
	}
	var output bytes.Buffer
	f := sprig.TxtFuncMap()
	f["lookup"] = engine.NewLookupFunction(restConfig)
	f["include"] = include
	tmpl := template.Must(template.New("objects").Funcs(f).Parse(input))
	err := tmpl.Execute(&output, valuesObj)
	if err != nil {
		return nil, fmt.Errorf("error rending template: %v", err)
	}
	// object is skipped due to condition in the template
	if len(output.String()) == 0 {
		return nil, nil
	}
	err = yaml.Unmarshal(output.Bytes(), newObj)
	if err != nil {
		return nil, err
	}
	return newObj, nil
}

// needed to assert convert ensure templates need little to no change at all
func generateMap(config *ovnoperatorv1.Configuration) (map[string]interface{}, error) {
	val := values{Values: config.Spec}
	out, err := json.Marshal(val)
	if err != nil {
		return nil, err
	}

	resultMap := make(map[string]interface{})
	err = json.Unmarshal(out, &resultMap)
	return resultMap, err
}

// generateIncludeValues renders the values generated the _helpers.tpl in the chart
func generateIncludeValues(config *ovnoperatorv1.Configuration) map[string]interface{} {
	nodeIPS := strings.Join(config.Status.MatchingNodeAddresses, ",")
	upgradeStratergyMap := map[string]interface{}{
		"upgradeStrategy": "RollingUpdate",
	}

	// https://github.com/kubernetes/apimachinery/blob/v0.32.1/pkg/runtime/converter.go#L614
	// converter only supports int64 and float64, which is why the forced type conversion
	// for versionCompatability and runAsUser
	versionCompatibiltyMap := map[string]interface{}{
		"versionCompatibility": float64(24.03),
	}

	runAsUser := int64(65534)
	if *config.Spec.Component.EnableOVNIPSec {
		runAsUser = int64(0)
	}

	return map[string]interface{}{
		"nodeCount": int64(len(config.Status.MatchingNodeAddresses)),
		"nodeIPs":   nodeIPS,
		"ovs-ovn":   upgradeStratergyMap,
		"ovn":       versionCompatibiltyMap,
		"runAsUser": runAsUser,
	}

}

// mimic helm include but in this case values are already pre-calculate in the
// map when we render the values
func include(key string, data map[string]interface{}) interface{} {
	// split key into fields

	fields := strings.Split(key, ".")
	val, _, _ := unstructured.NestedFieldCopy(data, fields...)
	return val
}

func InitialiseNewObject(object client.Object) client.Object {
	switch object.(type) {
	case *appsv1.Deployment:
		return &appsv1.Deployment{}
	case *apiextensionsv1.CustomResourceDefinition:
		return &apiextensionsv1.CustomResourceDefinition{}
	case *corev1.Secret:
		return &corev1.Secret{}
	case *corev1.ServiceAccount:
		return &corev1.ServiceAccount{}
	case *corev1.ConfigMap:
		return &corev1.ConfigMap{}
	case *rbacv1.RoleBinding:
		return &rbacv1.RoleBinding{}
	case *rbacv1.ClusterRole:
		return &rbacv1.ClusterRole{}
	case *rbacv1.ClusterRoleBinding:
		return &rbacv1.ClusterRoleBinding{}
	case *appsv1.DaemonSet:
		return &appsv1.DaemonSet{}
	case *corev1.Service:
		return &corev1.Service{}
	}
	return nil
}

func GenerateNorthBoundCleanupScript(nodeAddress string) (string, error) {
	return generateScript(nodeAddress, templates.CleanupNBDB)
}

func GenerateSouthBoundCleanupScript(nodeAddress string) (string, error) {
	return generateScript(nodeAddress, templates.CleanupSBDB)
}

func generateScript(nodeAddress, script string) (string, error) {
	values := map[string]string{
		"NodeAddress": nodeAddress,
	}
	tmpl, err := template.New("script").Parse(script)
	if err != nil {
		return "", fmt.Errorf("error parsing template %s: %v", script, err)
	}
	var result bytes.Buffer
	err = tmpl.Execute(&result, values)
	if err != nil {
		return "", fmt.Errorf("error during template execution %s using values %v: %v", script, values, err)
	}
	return result.String(), nil
}

func GenerateChassisCleanupScript(hostname string) (string, error) {
	values := map[string]string{
		"Hostname": hostname,
	}
	tmpl, err := template.New("script").Parse(templates.CleanupChassis)
	if err != nil {
		return "", fmt.Errorf("error parsing chassis cleanup template %s: %v", templates.CleanupChassis, err)
	}
	var result bytes.Buffer
	err = tmpl.Execute(&result, values)
	if err != nil {
		return "", fmt.Errorf("error during template execution %s using values %v: %v", templates.CleanupChassis, values, err)
	}
	return result.String(), nil
}
